module add(in1, in2, out);
  input [1:0] in1;
  input [1:0] in2;
  output [1:0] out;
  assign out = in1 + in2;
endmodule
module top(clk, rst, func, inCount, result);
  wire [1:0] _00_;
  wire _01_;
  wire [1:0] _02_;
  wire [31:0] _03_;
  wire [31:0] _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire [31:0] _10_;
  input clk;
  reg [1:0] counter;
  wire [1:0] counter_next;
  input [1:0] func;
  input [1:0] inCount;
  output [1:0] result;
  input rst;
  reg running;
  wire running_next;
  wire [1:0] sum;
  reg [1:0] word_sum;
  wire [1:0] word_sum_next;
  assign _05_ = func == 2'h2;
  assign _06_ = func == 1'h1;
  assign _07_ = counter > 1'h0;
  assign _08_ = counter > 1'h1;
  assign _09_ = _05_ && _07_;
  assign _03_[0] = running && _08_;
  always @(posedge clk)
      counter <= _00_;
  always @(posedge clk)
      word_sum <= _02_;
  always @(posedge clk)
      running <= _01_;
  assign _01_ = rst ? 1'h0 : running_next;
  assign _02_ = rst ? 2'h0 : word_sum_next;
  assign _00_ = rst ? 2'h0 : counter_next;
  assign _04_[1:0] = counter - 1'h1;
  assign running_next = _09_ ? 1'h1 : _03_[0];
  assign _10_[1:0] = running ? _04_[1:0] : counter;
  assign counter_next = _06_ ? inCount : _10_[1:0];
  assign word_sum_next = running ? sum : word_sum;
  add u0 (
    .in1(word_sum),
    .in2(2'h1),
    .out(sum)
  );
  assign result = word_sum;
endmodule
