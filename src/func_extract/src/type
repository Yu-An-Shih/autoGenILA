Binary file ./.op_constraint.cpp.swp matches
./ast.cpp:70:  toCoutVerb("!! Add child "+varAndSlice+" to "+node->dest);
./ast.cpp:76:      node->childVec.push_back(nextNode);
./ast.cpp:81:      node->childVec.push_back(existedNode);
./ast.cpp:87:      node->childVec.push_back(nextNode);
./ast.cpp:92:      node->childVec.push_back(existedNode);
./ast.cpp:103:  node->type = SRC_CONCAT;
./ast.cpp:104:  node->dest = var;
./ast.cpp:105:  node->op = "";
./ast.cpp:106:  node->srcVec = reg2Slices[var];
./ast.cpp:107:  node->destTime = timeIdx;
./ast.cpp:108:  node->done = false;
./ast.cpp:127:    node->type = NONBLOCK;
./ast.cpp:128:    node->dest = regAndSlice;
./ast.cpp:129:    node->op = "<=";
./ast.cpp:130:    node->srcVec.push_back(destNext);
./ast.cpp:131:    node->destTime = timeIdx;
./ast.cpp:132:    node->done = false;
./ast.cpp:193:  node->type = INPUT;
./ast.cpp:194:  node->dest = input;
./ast.cpp:195:  node->op = "";
./ast.cpp:196:  node->destTime = timeIdx;
./ast.cpp:197:  node->done = true;
./ast.cpp:203:  node->type = NUM;
./ast.cpp:204:  node->dest = num;
./ast.cpp:205:  node->op = "";
./ast.cpp:206:  node->destTime = timeIdx;
./ast.cpp:207:  node->done = true;
./ast.cpp:213:  node->type = AS;
./ast.cpp:214:  node->dest = as;
./ast.cpp:215:  node->op = "";
./ast.cpp:216:  node->destTime = timeIdx;
./ast.cpp:217:  node->done = true;
./ast.cpp:245:  node->type = TWO_OP;
./ast.cpp:246:  node->dest = destAndSlice;
./ast.cpp:247:  node->op = op;
./ast.cpp:248:  node->srcVec = SV{op1AndSlice, op2AndSlice};
./ast.cpp:249:  node->destTime = timeIdx;
./ast.cpp:250:  node->isReduceOp = isReduceOp;
./ast.cpp:251:  node->done = false;
./ast.cpp:280:  node->type = ONE_OP;
./ast.cpp:281:  node->dest = destAndSlice;
./ast.cpp:282:  node->op = op;
./ast.cpp:283:  node->srcVec = SV{op1AndSlice};
./ast.cpp:284:  node->destTime = timeIdx;
./ast.cpp:285:  node->done = false;
./ast.cpp:323:  node->type = ITE;
./ast.cpp:324:  node->dest = destAndSlice;
./ast.cpp:325:  node->op = "ite";
./ast.cpp:326:  node->srcVec = SV{condAndSlice, op1AndSlice, op2AndSlice};
./ast.cpp:327:  node->destTime = timeIdx;
./ast.cpp:328:  node->done = false;
./ast.cpp:350:  node->type = REDUCE1;
./ast.cpp:351:  node->dest = destAndSlice;
./ast.cpp:352:  node->op = op;
./ast.cpp:353:  node->srcVec = SV{op1AndSlice};
./ast.cpp:354:  node->destTime = timeIdx;
./ast.cpp:355:  node->done = false;
./ast.cpp:384:  node->type = SEL;
./ast.cpp:385:  node->dest = destAndSlice;
./ast.cpp:386:  node->op = op;
./ast.cpp:387:  node->srcVec = SV{op1AndSlice, op2AndSlice, integer};
./ast.cpp:388:  node->destTime = timeIdx;
./ast.cpp:389:  node->isReduceOp = false;
./ast.cpp:390:  node->done = false;
./ast.cpp:423:  node->type = SRC_CONCAT;
./ast.cpp:424:  node->dest = destAndSlice;
./ast.cpp:425:  node->op = "";
./ast.cpp:426:  node->srcVec = srcVec;
./ast.cpp:427:  node->destTime = timeIdx;
./ast.cpp:428:  node->done = false;
./ast.cpp:450:  node->type = CASE;
./ast.cpp:451:  node->dest = var;
./ast.cpp:452:  node->op = "";
./ast.cpp:453:  //node->srcVec = SV{op1AndSlice, op2AndSlice, integer};
./ast.cpp:458:  node->srcVec.push_back(caseVar);
./ast.cpp:463:    node->srcVec.push_back(caseAssign.first);
./ast.cpp:464:    node->srcVec.push_back(caseAssign.second);
./ast.cpp:466:  node->destTime = timeIdx;
./ast.cpp:467:  node->isReduceOp = false;
./ast.cpp:468:  node->done = false;
./check_regs.cpp:287:  std::string var = node->dest;
./check_regs.cpp:294:  if(node->srcVec.size() != node->childVec.size() && node->type != ITE) {
./check_regs.cpp:295:    toCout("Error: srcVec and childVec has different length: "+node->dest);
./check_regs.cpp:337:  std::string dest = node->dest;
./check_regs.cpp:345:  assert(!is_number(node->childVec.front()->dest));
./check_regs.cpp:349:    std::string destNext = node->srcVec.front();
./check_regs.cpp:352:    destNextExpr = add_constraint(node->childVec.front(), timeIdx+1, c, s, g, bound, isSolve);
./check_regs.cpp:405:  toCoutVerb("Add ssa constraint for: " + node->dest+" ------  time: "+toStr(timeIdx));
./check_regs.cpp:406:  std::string var = node->dest;
./check_regs.cpp:408:  switch( node->type ) {
./check_regs.cpp:445:  //toCoutVerb("Add clean constraint for: " + node->dest);
./check_regs.cpp:446:  std::string dest = node->dest;
./check_regs.cpp:465:  //  if(isSolve) s.add( destExpr == hdb2int(node->dest) );
./check_regs.cpp:487:  toCoutVerb("Add dirty constraint for: " + node->dest+" ------  time: "+toStr(timeIdx));  
./check_regs.cpp:488:  std::string destAndSlice = node->dest;
./check_regs.cpp:524:  toCoutVerb("push into dirty queue: "+node->dest);
./op_constraint.cpp:100:  std::string dest = node->dest;
./op_constraint.cpp:127:  std::string dest = node->dest;
./op_constraint.cpp:139:  toCoutVerb("Two op constraint for :"+node->dest);
./op_constraint.cpp:141:  bool isReduceOp = node->isReduceOp;
./op_constraint.cpp:142:  assert(node->srcVec.size() == 2);
./op_constraint.cpp:143:  std::string destAndSlice = node->dest;
./op_constraint.cpp:144:  std::string op1AndSlice = node->srcVec[0];
./op_constraint.cpp:145:  std::string op2AndSlice = node->srcVec[1];
./op_constraint.cpp:179:  //if(!isReduceOp && !is_bool_op(node->op))
./op_constraint.cpp:197:    if(!op1Slice.empty())  op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve).extract(op1Hi, op1Lo); 
./op_constraint.cpp:198:    else                   op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve); 
./op_constraint.cpp:203:    if(!op2Slice.empty())  op2Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve).extract(op2Hi, op2Lo);
./op_constraint.cpp:204:    else                   op2Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:261:  return make_z3_expr<expr, expr>(s, g, c, node->op, destExpr, op1Expr, op2Expr, isSolve, destWidthNum, op1WidthNum, op2WidthNum);
./op_constraint.cpp:266:  toCoutVerb("One op constraint for :"+node->dest);
./op_constraint.cpp:268:  assert(node->srcVec.size() == 1);
./op_constraint.cpp:271:  std::string destAndSlice = node->dest;
./op_constraint.cpp:272:  std::string op1AndSlice = node->srcVec.front();
./op_constraint.cpp:279:  expr op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve).extract(op1Hi, op1Lo);
./op_constraint.cpp:285:  return make_z3_expr(s, g, c, node->op, destExpr, op1Expr, isSolve);
./op_constraint.cpp:290:  toCoutVerb("Reduce one op constraint for: "+node->dest);
./op_constraint.cpp:292:  assert(node->srcVec.size() == 1);
./op_constraint.cpp:295:  std::string destAndSlice = node->dest;
./op_constraint.cpp:296:  std::string op1AndSlice = node->srcVec.front();
./op_constraint.cpp:307:  expr op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve).extract(op1Hi, op1Lo);
./op_constraint.cpp:314:  return make_z3_expr(s, g, c, node->op, destExpr, op1Expr, isSolve);  
./op_constraint.cpp:320:  assert(node->srcVec.size() == 3);
./op_constraint.cpp:321:  std::string destAndSlice = node->dest;
./op_constraint.cpp:322:  std::string op = node->srcVec[0]; // op1 is var to be selected
./op_constraint.cpp:323:  uint32_t int1 = std::stoi(node->srcVec[1]); // op1 is var to be selected
./op_constraint.cpp:324:  uint32_t int2 = std::stoi(node->srcVec[2]); // op2 is start index
./op_constraint.cpp:328:  expr opExpr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:342:  toCoutVerb("Sel op constraint for :"+node->dest);
./op_constraint.cpp:343:  if(node->op == "sel5")
./op_constraint.cpp:347:  assert(node->srcVec.size() == 3);
./op_constraint.cpp:348:  std::string destAndSlice = node->dest;
./op_constraint.cpp:349:  std::string op1AndSlice = node->srcVec[0]; // op1 is var to be selected
./op_constraint.cpp:350:  std::string op2AndSlice = node->srcVec[1]; // op2 is start index
./op_constraint.cpp:351:  std::string integer = node->srcVec[2];     // integer is the length of range
./op_constraint.cpp:391:    if(!op1Slice.empty()) op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve).extract(op1Hi, op1Lo);
./op_constraint.cpp:392:    else                  op1Expr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:395:    if(!op2Slice.empty()) op2Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve).extract(op2Hi, op2Lo);
./op_constraint.cpp:396:    else                  op2Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:418:    if(node->op == "sel1" || node->op == "sel2") {
./op_constraint.cpp:429:    else if(node->op == "sel3" || node->op == "sel4")
./op_constraint.cpp:451:  toCoutVerb("Src concat op constraint for: "+node->dest);
./op_constraint.cpp:453:  std::string destAndSlice = node->dest;
./op_constraint.cpp:458:  expr destExpr = var_expr(destAndSlice, timeIdx, c, false);//add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve).extract(destHi, destLo);
./op_constraint.cpp:460:  if(node->dest == "fangyuan27" ) {
./op_constraint.cpp:465:    std::string firstSrcAndSlice = node->srcVec[0];
./op_constraint.cpp:466:    //expr firstSrcExpr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:467:    //expr firstSrcExpr_t = var_expr(node->srcVec[0], timeIdx, c, true);
./op_constraint.cpp:480:  if(node->dest == "fangyuan27" && nxtIdx == 0) {
./op_constraint.cpp:485:  std::string childVarAndSlice = node->childVec[nxtIdx]->dest;
./op_constraint.cpp:490:  auto it = std::find(node->srcVec.begin(), node->srcVec.end(), childVar);
./op_constraint.cpp:491:  assert(it != node->srcVec.end());
./op_constraint.cpp:493:    firstSrcExpr = add_constraint(node->childVec[nxtIdx], timeIdx, c, s, g, bound, isSolve).extract(hi, lo);
./op_constraint.cpp:497:  if(nxtIdx == node->childVec.size() - 1)
./op_constraint.cpp:503:  toCoutVerb("Finished idx: "+toStr(nxtIdx)+" for: "+node->dest);
./op_constraint.cpp:504:  if(node->dest == "fangyuan27" && nxtIdx == 1) {
./op_constraint.cpp:514:  toCoutVerb("Ite op constraint for :"+node->dest);
./op_constraint.cpp:515:  assert(node->type == ITE);
./op_constraint.cpp:516:  assert(node->srcVec.size() == 3);
./op_constraint.cpp:518:  std::string destAndSlice = node->dest;
./op_constraint.cpp:519:  std::string condAndSlice = node->srcVec[0];
./op_constraint.cpp:520:  std::string op1AndSlice = node->srcVec[1];
./op_constraint.cpp:521:  std::string op2AndSlice = node->srcVec[2];
./op_constraint.cpp:576:  if(!condSlice.empty()) condExpr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve, true).extract(condHi, condLo);
./op_constraint.cpp:577:  else                   condExpr = add_constraint(node->childVec[0], timeIdx, c, s, g, bound, isSolve, true);
./op_constraint.cpp:586:    op1Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve).extract(op1Hi, op1Lo);
./op_constraint.cpp:587:  else                  op1Expr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:588:  if(!op2Slice.empty()) op2Expr = add_constraint(node->childVec[2], timeIdx, c, s, g, bound, isSolve).extract(op2Hi, op2Lo);
./op_constraint.cpp:589:  else                  op2Expr = add_constraint(node->childVec[2], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:623:  toCoutVerb("Case op constraint for :"+node->dest);  
./op_constraint.cpp:624:  assert(node->type == CASE);
./op_constraint.cpp:625:  assert(node->srcVec.size() % 2 == 1);
./op_constraint.cpp:627:  std::string destAndSlice = node->dest;
./op_constraint.cpp:628:  std::string caseVarAndSlice = node->srcVec[0];
./op_constraint.cpp:631:  expr caseExpr = add_constraint( node->childVec[0], timeIdx, c, s, g, bound, isSolve, false).extract(caseHi, caseLo);
./op_constraint.cpp:633:  expr assignVarExpr = add_constraint(node->childVec[1], timeIdx, c, s, g, bound, isSolve);
./op_constraint.cpp:634:  expr assignVarExpr_t = var_expr(node->childVec[1]->dest, timeIdx, c, true);
./op_constraint.cpp:642:    for(uint32_t i = node->srcVec.size()-1; i > 0; i--) {
./op_constraint.cpp:644:        assignVarAndSlice = node->srcVec[i];
./op_constraint.cpp:648:        caseValue = node->srcVec[i];
./op_constraint.cpp:656:          expr defaultVarExpr = add_constraint(node->childVec[2], timeIdx, c, s, g, bound, isSolve).extract(Hi, Lo);
./op_constraint.cpp:696:  std::string assignVarAndSlice = node->srcVec[idx+1];
./op_constraint.cpp:699:  if(idx < node->srcVec.size()-2) {
./op_constraint.cpp:700:    assignNode = node->childVec[1];
./op_constraint.cpp:701:    std::string caseValue = node->srcVec[idx];
./op_constraint.cpp:708:    assignNode = node->childVec[2];
Binary file ./.check_regs.cpp.swp matches
Binary file ./.ast.cpp.swp matches
