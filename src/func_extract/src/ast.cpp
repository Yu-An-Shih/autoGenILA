#include "ast.h"
#include "../../taint_method/taint_gen.h"


// "line" is verilog line generated by Yosys
void build_ast_tree() {
  for(std::string reg: moduleAs) {
    if(reg2Slices.find(reg) == reg2Slices.end()) {
      build_tree_for_single_as(reg);
    }
    else { // if different slices are assigned differently
      for(std::string regAndSlice: reg2Slices[reg]) {
        build_tree_for_single_as(regAndSlice);
      }
    }
  }
}


void build_tree_for_single_as(std::string regAndSlice) {
  toCoutVerb("Begin check: "+regAndSlice);
  uint32_t regWidth = get_var_slice_width(regAndSlice);
  astNode* root = new astNode;
  g_asSliceRoot.emplace(regAndSlice, root);
  add_node(regAndSlice, 0, root);
}


bool add_node(std::string var, uint32_t timeIdx, astNode* const node ) {
  if ( isInput(var) ) {
    add_input_node(var, timeIdx, node);
  }
  else if ( isAs(var) ) {
    add_as_node(var, timeIdx, node);    
  }
  else if( isReg(var) ) {
    add_nb_node(var, timeIdx, node);
  }
  else { // it is wire
    add_ssa_node(var, timeIdx, node);
  }
}


// timeIdx is time for dest, not src in the expression
bool add_nb_node(std::string regAndSlice, uint32_t timeIdx, astNode* const node) {
  toCoutVerb("Add nb node for :" + regAndSlice);
  std::string destAssign = g_nbTable[regAndSlice];
  std::smatch m;
  if(std::regex_match(destAssign, m, pNonblock)) {
    std::string destNext = m.str(3);
    uint32_t destNextWidth = get_var_slice_width(destNext);
    uint32_t destWidth = get_var_slice_width(regAndSlice);
    std::string regAndSliceTimed = regAndSlice+"#"+toStr(timeIdx);
    std::string destNextTimed = destNext+"#"+toStr(timeIdx+1);

    ast* nextNode = new astNode;
    node->type = NONBLOCK;
    node->dest = regAndSliceTimed;
    node->op = "<=";
    node->srcVec.push_back(destNextTimed);
    node->childVec.push_back(nextNode);
    node->destTime = timeIdx;
    node->done = false;
    return add_ssa_constraint(destNext, timeIdx+1, nextNode);
  }
  else if(std::regex_match(destAssign, m, pNonblockConcat)) {
  }
  else if(std::regex_match(destAssign, m, pNonblockIf)) {
  }
  else {
    toCout("Error in add_nb_constraint: "+destAssign);
  }
}


bool add_ssa_node(std::string var, uint32_t timeIdx, astNode* const node) {
  toCoutVerb("Add ssa node for :" + var);  
  std::string varAssign = g_ssaTable[var];
  std::smatch m;
  uint32_t choice = parse_verilog_line(varAssign);
  switch( choice ) {
    case INPUT:
      add_input_node(varAssign, timeIdx, node);
      break;
    case TWO_OP:
      add_two_op_node(varAssign, timeIdx, node);
      break;
    case ONE_OP:
      add_one_op_node(varAssign, timeIdx, node);
      break;
    case REDUCE1:
      add_reduce_op_node(varAssign, timeIdx, node);
      break;
    case SEL:
      add_sel_op_node(varAssign, timeIdx, node);
      break;
    case SRC_CONCAT:
      add_src_concat_op_node(varAssign, timeIdx, node);
      break;
    case ITE:
      add_ite_op_node(varAssign, timeIdx, node);
      break;
    default:
      toCout("Error in add_ssa_constraint for: "+var);
      break;
  }
}


void add_input_node(std::string input, uint32_t timeIdx, astNode* const node) {
  node->type = INPUT;
  node->dest = input+"#"+toStr(timeIdx);
  node->op = "";
  node->destTime = timeIdx;
  node->done = true;
}


void add_as_node(std::string as, uint32_t timeIdx, astNode* const node) {
  node->type = AS;
  node->dest = as+"#"+toStr(timeIdx);
  node->op = "";
  node->destTime = timeIdx;
  node->done = true;
}


void add_two_op_node(std::string line, uint32_t timeIdx, astNode* const node) {
  toCoutVerb("Two op for :"+line);
  std::smatch m;  
  bool isReduceOp;
  std::string op;
  if (!check_two_op(line, op, isReduceOp))
    return;

  assert(!m.str(3).empty());
  assert(!m.str(4).empty());
  bool op1IsWire = isWire(m.str(3));
  bool op2IsWire = isWire(m.str(4));
  bool op1IsAs, op2IsAs;
  //bool op1IsNum = isNum(m.str(3));
  //bool op2IsNum = isNum(m.str(4));
  std::string blank = m.str(1);
  std::string dest, destSlice;
  std::string op1, op1Slice;
  std::string op2, op2Slice;
  std::string destAndSlice = m.str(2);
  std::string op1AndSlice = m.str(3);
  std::string op2AndSlice = m.str(4);
  split_slice(destAndSlice, dest, destSlice);
  split_slice(op1AndSlice, op1, op1Slice);
  split_slice(op2AndSlice, op2, op2Slice);
  uint32_t destAndSliceWidth = get_var_slice_width(destAndSlice);
  uint32_t op1AndSliceWidth = get_var_slice_width(op1AndSlice);
  uint32_t op2AndSliceWidth = get_var_slice_width(op2AndSlice);

  astNode* op1Node = new astNode;
  astNode* op2Node = new astNode;
  node->type = TWO_OP;
  node->dest = destAndSlice+"#"+toStr(timeIdx);
  node->op = op;
  node->srcVec = SV{op1AndSlice+"#"+toStr(timeIdx), op2AndSlice+"#"+toStr(timeIdx)};
  node->childVec = PV{op1Node, op2Node};
  node->destTime = timeIdx;
  node->done = false;

  add_node(op1AndSlice, timeIdx, op1Node);
  add_node(op2AndSlice, timeIdx, op2Node);

  if(isReduceOp)
    assert(destAndSliceWidth == 1);

  assert(!isMem(op1));
  assert(!isMem(op2));
}


void add_one_op_node(std::string line, uint32_t timeIdx, astNode* const node) {
  toCoutVerb("One op for :"+line); 
  std::smatch m;
  std::string op;
  if (!check_one_op(line, op))
    return;
  assert(!m.str(2).empty());
  assert(!m.str(3).empty());
 
  std::string blank = m.str(1);
  std::string dest, destSlice;
  std::string op1, op1Slice;
  std::string destAndSlice = m.str(2);
  std::string op1AndSlice = m.str(3);
  split_slice(destAndSlice, dest, destSlice);
  split_slice(op1AndSlice, op1, op1Slice);

  std::string destAndSliceTimed = destAndSlice + "#" + toStr(timeIdx);

  astNode* op1Node = new astNode;  
  node->type = ONE_OP;
  node->dest = destAndSlice+"#"+toStr(timeIdx);
  node->op = op;
  node->srcVec = SV{op1AndSlice+"#"+toStr(timeIdx)};
  node->childVec = PV{op1Node};
  node->destTime = timeIdx;
  node->done = false;

  add_node(op1AndSlice, timeIdx, op1Node);  
}


void add_ite_op_node(std::string line, uint32_t timeIdx, astNode* const node) {
  toCoutVerb("add Ite node for :"+line);
  std::smatch m;
  if ( !std::regex_match(line, m, pIte) )
    return;
  assert(!m.str(3).empty());
  assert(!m.str(4).empty());
  assert(!m.str(5).empty());

  std::string dest, destSlice;
  std::string cond, condSlice;
  std::string op1, op1Slice;
  std::string op2, op2Slice;
  std::string blank = m.str(1);
  std::string destAndSlice = m.str(2);
  std::string condAndSlice = m.str(3);
  std::string op1AndSlice = m.str(4);
  std::string op2AndSlice = m.str(5);
  split_slice(destAndSlice, dest, destSlice);
  split_slice(condAndSlice, cond, condSlice);
  split_slice(op1AndSlice , op1, op1Slice);
  split_slice(op2AndSlice , op2, op2Slice);

  assert(!isMem(op1));    
  assert(!isMem(op2));

  uint32_t localWidthNum;
  std::string localWidth;
  localWidthNum = get_var_slice_width(destAndSlice);

  localWidth = std::to_string(localWidthNum);

  astNode* condNode = new astNode;  
  astNode* op1Node = new astNode;  
  astNode* op2Node = new astNode;  
  node->type = ITE;
  node->dest = destAndSlice+"#"+toStr(timeIdx);
  node->op = "ite";
  node->srcVec = SV{condAndSlice+"#"+toStr(timeIdx), op1AndSlice+"#"+toStr(timeIdx), op2AndSlice+"#"+toStr(timeIdx)};
  node->childVec = PV{condNode, op1Node, op2Node};
  node->destTime = timeIdx;
  node->done = false;

  add_node(condAndSlice, timeIdx, condNode);  
  add_node(op1AndSlice, timeIdx, op1Node);  
  add_node(op2AndSlice, timeIdx, op2Node);  
}
