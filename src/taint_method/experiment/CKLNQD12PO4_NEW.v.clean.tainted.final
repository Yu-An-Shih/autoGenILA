module CKLNQD12PO4 ( CP , E , TE , rst_zy , CP_T , E_T , Q_R0 , Q_C0 , TE_T , Q , CP_R , CP_X , CP_C , E_R , E_X , E_C , Q_T , TE_R , TE_X , TE_C );
  input rst_zy;
  integer i;
  logic INSTR_IN_ZY;
  assign INSTR_IN_ZY = CP_T > 0 || E_T > 0 || TE_T > 0 || 0 ;
  logic _0_;
  logic _0__T ;
  logic _0__R ;
  logic _0__C ;
  logic _0__X ;
  logic [1:0] _0__S ;
  input CP;
  input CP_T ;
  wire [1:0] CP_S ;
  output CP_R ;
  output CP_X ;
  output CP_C ;
  assign CP_S = 0 ;
  input E;
  input E_T ;
  wire [1:0] E_S ;
  output E_R ;
  output E_X ;
  output E_C ;
  assign E_S = 0 ;
  output Q;
  logic Q ;
  output Q_T ;
  logic Q_T ;
  logic Q_R ;
  logic Q_C ;
  logic Q_X ;
  logic [1:0] Q_S ;
  input Q_R0 ;
  input Q_C0 ;
  wire Q_X0 ;
  assign Q_X0 = Q_R0 ;
  input TE;
  input TE_T ;
  wire [1:0] TE_S ;
  output TE_R ;
  output TE_X ;
  output TE_C ;
  assign TE_S = 0 ;
  logic qd;
  logic  qd_T ;
  logic  qd_flip ;
  logic  qd_PREV_VAL1 ;
  logic  qd_PREV_VAL2 ;
  logic  qd_R ;
  logic  qd_X ;
  logic  qd_C ;
  logic [1:0] qd_S ;
  logic qd_t_flag ;
  logic qd_r_flag ;
  assign qd_S = 3 ;
  assign Q = CP & qd;
  assign Q_S = 0 ;
  logic [0:0] CP_C0 ;
  logic [0:0] CP_R0 ;
  logic [0:0] CP_X0 ;
  logic [0:0] qd_C0 ;
  logic [0:0] qd_R0 ;
  logic [0:0] qd_X0 ;
  assign Q_T = CP_T | qd_T ;
  assign CP_C0 = 0 ;
  assign qd_C0 = 0 ;
  assign CP_R0 = Q_R ;
  assign qd_R0 = Q_R ;
  assign CP_X0 = Q_R ;
  assign qd_X0 = Q_R ;
  assign _0_ = TE | E;
  assign _0__S = 0 ;
  logic [0:0] TE_C0 ;
  logic [0:0] TE_R0 ;
  logic [0:0] TE_X0 ;
  logic [0:0] E_C0 ;
  logic [0:0] E_R0 ;
  logic [0:0] E_X0 ;
  assign _0__T = TE_T | E_T ;
  assign TE_C0 = _0__C ;
  assign TE_X0 = _0__X ;
  assign E_C0 = _0__C ;
  assign E_X0 = _0__X ;
  assign TE_R0 = ( _0__R | _0__C & E_T ) & { 1{ E != 1'b1 }} ;
  assign E_R0 = ( _0__R | _0__C & TE_T ) & { 1{ TE != 1'b1 }} ;
  always @(negedge CP)
      qd <= _0_;
  assign qd_T = 0;
  assign qd_r_flag = 0;
  assign qd_t_flag = 0;
  assign E_C = ( E_C0 );
  assign TE_C = ( TE_C0 );
  assign qd_C = ( qd_C0 );
  assign Q_C = ( Q_C0 );
  assign CP_C = ( CP_C0 );
  assign E_X = ( E_X0 );
  assign TE_X = ( TE_X0 );
  assign qd_X = ( qd_X0 );
  assign Q_X = ( Q_X0 );
  assign CP_X = ( CP_X0 );
  assign E_R = ( E_X0 & E_R0 );
  assign TE_R = ( TE_X0 & TE_R0 );
  assign qd_R = ( qd_X0 & qd_R0 );
  assign Q_R = ( Q_X0 & Q_R0 );
  assign CP_R = ( CP_X0 & CP_R0 );
 // ground taints for floating regs
 // ground taints for used wires
  assign { _0__R , _0__C  } = 0;
  always @( posedge  ) begin
    if( rst_zy ) qd_PREV_VAL1 <= 0 ;
    if( rst_zy ) qd_PREV_VAL2 <= 0 ;
    if( INSTR_IN_ZY ) qd_PREV_VAL1 <= qd ;
    if( INSTR_IN_ZY ) qd_PREV_VAL2 <= qd_PREV_VAL1 ;
  end
 // ground taints for unused wire slices
  assert property( qd_r_flag == 0 || qd_PREV_VAL1 == qd_PREV_VAL2 );
  logic write_taint_exist = 0 || qd_T ;
  logic reg_flipping = 0 || qd_flip ;
endmodule
