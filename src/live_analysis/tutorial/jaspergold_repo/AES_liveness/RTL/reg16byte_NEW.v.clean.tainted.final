module reg16byte ( addr , clk , data_in , en , rst , wr , INSTR_IN_ZY , zy_end_sig , rst_zy , data_out , reg_out , wr_R );
  input rst_zy;
  input zy_end_sig;
  integer i;
  input INSTR_IN_ZY;
  logic [127:0] _000_;
  logic _001_;
  logic _002_;
  logic _003_;
  logic _004_;
  logic _005_;
  logic _006_;
  logic _007_;
  logic _008_;
  logic _009_;
  logic _010_;
  logic _011_;
  logic _012_;
  logic _013_;
  logic _014_;
  logic _015_;
  logic _016_;
  logic _017_;
  logic [7:0] _018_;
  logic [7:0] _019_;
  logic [7:0] _020_;
  logic [7:0] _021_;
  logic [7:0] _022_;
  logic [7:0] _023_;
  logic [7:0] _024_;
  logic [7:0] _025_;
  logic [7:0] _026_;
  logic [7:0] _027_;
  logic [7:0] _028_;
  logic [7:0] _029_;
  logic [7:0] _030_;
  logic [7:0] _031_;
  input [3:0] addr;
  input clk;
  input [7:0] data_in;
  output [7:0] data_out;
  logic [7:0] data_out ;
  logic [7:0] data_out_mux;
  input en;
  logic [7:0] reg0_next;
  logic [7:0] reg10_next;
  logic [7:0] reg11_next;
  logic [7:0] reg12_next;
  logic [7:0] reg13_next;
  logic [7:0] reg14_next;
  logic [7:0] reg15_next;
  logic [7:0] reg1_next;
  logic [7:0] reg2_next;
  logic [7:0] reg3_next;
  logic [7:0] reg4_next;
  logic [7:0] reg5_next;
  logic [7:0] reg6_next;
  logic [7:0] reg7_next;
  logic [7:0] reg8_next;
  logic [7:0] reg9_next;
  output [127:0] reg_out;
  logic [127:0] reg_out ;
  logic [127:0] reg_out;
  logic [127:0]  reg_out_PREV_VAL1 ;
  input rst;
  input wr;
  logic wr0;
  logic wr1;
  logic wr10;
  logic wr11;
  logic wr12;
  logic wr13;
  logic wr14;
  logic wr15;
  logic wr2;
  logic wr3;
  logic wr4;
  logic wr5;
  logic wr6;
  logic wr7;
  logic wr8;
  logic wr9;
  assign _001_ = ! addr;
  assign _002_ = addr == 1'b1;
  assign _003_ = addr == 2'b10;
  assign _004_ = addr == 2'b11;
  assign _005_ = addr == 3'b100;
  assign _006_ = addr == 3'b101;
  assign _007_ = addr == 3'b110;
  assign _008_ = addr == 3'b111;
  assign _009_ = addr == 4'b1000;
  assign _010_ = addr == 4'b1001;
  assign _011_ = addr == 4'b1010;
  assign _012_ = addr == 4'b1011;
  assign _013_ = addr == 4'b1100;
  assign _014_ = addr == 4'b1101;
  assign _015_ = addr == 4'b1110;
  assign _016_ = addr == 4'b1111;
  assign _017_ = en && wr;
  assign wr0 = _017_ && _001_;
  assign wr1 = _017_ && _002_;
  assign wr2 = _017_ && _003_;
  assign wr3 = _017_ && _004_;
  assign wr4 = _017_ && _005_;
  assign wr5 = _017_ && _006_;
  assign wr6 = _017_ && _007_;
  assign wr7 = _017_ && _008_;
  assign wr8 = _017_ && _009_;
  assign wr9 = _017_ && _010_;
  assign wr10 = _017_ && _011_;
  assign wr11 = _017_ && _012_;
  assign wr12 = _017_ && _013_;
  assign wr13 = _017_ && _014_;
  assign wr14 = _017_ && _015_;
  assign wr15 = _017_ && _016_;
  always @(posedge clk)
      reg_out <= _000_;
  assign _000_[127:120] = rst ? 8'b00000000 : reg15_next;
  assign _000_[119:112] = rst ? 8'b00000000 : reg14_next;
  assign _000_[111:104] = rst ? 8'b00000000 : reg13_next;
  assign _000_[103:96] = rst ? 8'b00000000 : reg12_next;
  assign _000_[95:88] = rst ? 8'b00000000 : reg11_next;
  assign _000_[87:80] = rst ? 8'b00000000 : reg10_next;
  assign _000_[79:72] = rst ? 8'b00000000 : reg9_next;
  assign _000_[71:64] = rst ? 8'b00000000 : reg8_next;
  assign _000_[63:56] = rst ? 8'b00000000 : reg7_next;
  assign _000_[55:48] = rst ? 8'b00000000 : reg6_next;
  assign _000_[47:40] = rst ? 8'b00000000 : reg5_next;
  assign _000_[39:32] = rst ? 8'b00000000 : reg4_next;
  assign _000_[31:24] = rst ? 8'b00000000 : reg3_next;
  assign _000_[23:16] = rst ? 8'b00000000 : reg2_next;
  assign _000_[15:8] = rst ? 8'b00000000 : reg1_next;
  assign _000_[7:0] = rst ? 8'b00000000 : reg0_next;
  assign reg0_next = wr0 ? data_in : reg_out[7:0];
  assign reg1_next = wr1 ? data_in : reg_out[15:8];
  assign reg2_next = wr2 ? data_in : reg_out[23:16];
  assign reg3_next = wr3 ? data_in : reg_out[31:24];
  assign reg4_next = wr4 ? data_in : reg_out[39:32];
  assign reg5_next = wr5 ? data_in : reg_out[47:40];
  assign reg6_next = wr6 ? data_in : reg_out[55:48];
  assign reg7_next = wr7 ? data_in : reg_out[63:56];
  assign reg8_next = wr8 ? data_in : reg_out[71:64];
  assign reg9_next = wr9 ? data_in : reg_out[79:72];
  assign reg10_next = wr10 ? data_in : reg_out[87:80];
  assign reg11_next = wr11 ? data_in : reg_out[95:88];
  assign reg12_next = wr12 ? data_in : reg_out[103:96];
  assign reg13_next = wr13 ? data_in : reg_out[111:104];
  assign reg14_next = wr14 ? data_in : reg_out[119:112];
  assign reg15_next = wr15 ? data_in : reg_out[127:120];
  assign _018_ = _015_ ? reg_out[119:112] : reg_out[127:120];
  assign _019_ = _014_ ? reg_out[111:104] : _018_;
  assign _020_ = _013_ ? reg_out[103:96] : _019_;
  assign _021_ = _012_ ? reg_out[95:88] : _020_;
  assign _022_ = _011_ ? reg_out[87:80] : _021_;
  assign _023_ = _010_ ? reg_out[79:72] : _022_;
  assign _024_ = _009_ ? reg_out[71:64] : _023_;
  assign _025_ = _008_ ? reg_out[63:56] : _024_;
  assign _026_ = _007_ ? reg_out[55:48] : _025_;
  assign _027_ = _006_ ? reg_out[47:40] : _026_;
  assign _028_ = _005_ ? reg_out[39:32] : _027_;
  assign _029_ = _004_ ? reg_out[31:24] : _028_;
  assign _030_ = _003_ ? reg_out[23:16] : _029_;
  assign _031_ = _002_ ? reg_out[15:8] : _030_;
  assign data_out = _001_ ? reg_out[7:0] : _031_;
  assign data_out_mux = data_out;
 // ground taints for floating regs
  assign reg_out_R = 0;
 // ground taints for unused wires
  assign { _000__R , _001__R , _002__R , _003__R , _004__R , _005__R , _006__R , _007__R , _008__R , _009__R , _010__R , _011__R , _012__R , _013__R , _014__R , _015__R , _016__R , _017__R , _018__R , _019__R , _020__R , _021__R , _022__R , _023__R , _024__R , _025__R , _026__R , _027__R , _028__R , _029__R , _030__R , _031__R , data_out_mux_R , reg0_next_R , reg10_next_R , reg11_next_R , reg12_next_R , reg13_next_R , reg14_next_R , reg15_next_R , reg1_next_R , reg2_next_R , reg3_next_R , reg4_next_R , reg5_next_R , reg6_next_R , reg7_next_R , reg8_next_R , reg9_next_R , wr0_R , wr1_R , wr10_R , wr11_R , wr12_R , wr13_R , wr14_R , wr15_R , wr2_R , wr3_R , wr4_R , wr5_R , wr6_R , wr7_R , wr8_R , wr9_R , addr_R , clk_R , data_in_R , en_R , rst_R , wr_R  } = 0;
  always @( posedge clk ) begin
    if( rst_zy ) reg_out_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) reg_out_PREV_VAL1 <= reg_out ;
  end
 // ground taints for unused wire slices
  assert property( !INSTR_IN_ZY  || reg_out_PREV_VAL1 == 0 );
endmodule
