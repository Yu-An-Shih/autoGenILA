  logic [511:0] _00_;
  logic [511:0] _00__T ;
  logic [511:0] _00__R ;
  logic [13:0] _00__S ;
  logic _01_;
  logic _01__T ;
  logic _01__R ;
  logic [13:0] _01__S ;
  logic _02_;
  logic _02__T ;
  logic _02__R ;
  logic [13:0] _02__S ;
  logic _03_;
  logic _03__T ;
  logic _03__R ;
  logic [13:0] _03__S ;
  logic _04_;
  logic _04__T ;
  logic _04__R ;
  logic [13:0] _04__S ;
  logic _05_;
  logic _05__T ;
  logic _05__R ;
  logic [13:0] _05__S ;
  logic _06_;
  logic _06__T ;
  logic _06__R ;
  logic [13:0] _06__S ;
  logic _07_;
  logic _07__T ;
  logic _07__R ;
  logic [13:0] _07__S ;
  logic _08_;
  logic _08__T ;
  logic _08__R ;
  logic [13:0] _08__S ;
  logic _09_;
  logic _09__T ;
  logic _09__R ;
  logic [13:0] _09__S ;
  logic _10_;
  logic _10__T ;
  logic _10__R ;
  logic [13:0] _10__S ;
  logic _11_;
  logic _11__T ;
  logic _11__R ;
  logic [13:0] _11__S ;
  logic [511:0] _12_;
  logic [511:0] _12__T ;
  logic [511:0] _12__R ;
  logic [13:0] _12__S ;
  logic _13_;
  logic _13__T ;
  logic _13__R ;
  logic [13:0] _13__S ;
  logic \FIFO_REG.delta ;
  logic \FIFO_REG.delta_T ;
  logic \FIFO_REG.delta_R ;
  logic [13:0] \FIFO_REG.delta_S ;
  logic active;
  logic active_T ;
  logic active_R ;
  logic [13:0] active_S ;
  input arst;
  input arst_T ;
  output arst_R ;
  input [13:0] arst_S ;
  logic [511:0] buff;
  logic [511:0]  buff_T ;
  logic [511:0]  buff_PREV_VAL1 ;
  logic [511:0]  buff_PREV_VAL2 ;
  logic [511:0]  buff_R ;
  logic [13:0] buff_S ;
  logic buff_t_flag ;
  logic buff_r_flag ;
  assign buff_S = 7 ;
  logic [511:0] buff_nxt;
  logic [511:0] buff_nxt_T ;
  logic [511:0] buff_nxt_R ;
  logic [13:0] buff_nxt_S ;
  logic [511:0] buff_pre;
  logic [511:0] buff_pre_T ;
  logic [511:0] buff_pre_R ;
  logic [13:0] buff_pre_S ;
  input clk;
  input clk_T ;
  output clk_R ;
  input [13:0] clk_S ;
  logic count;
  logic count_T ;
  logic count_R ;
  logic [13:0] count_S ;
  logic [31:0] count_t;
  logic [31:0] count_t_T ;
  logic [31:0] count_t_R ;
  logic [13:0] count_t_S ;
  input [511:0] d;
  input [511:0] d_T ;
  output [511:0] d_R ;
  input [13:0] d_S ;
  input en;
  input en_T ;
  output en_R ;
  input [13:0] en_S ;
  logic en_l;
  logic en_l_T ;
  logic en_l_R ;
  logic [13:0] en_l_S ;
  logic en_l_s;
  logic en_l_s_T ;
  logic en_l_s_R ;
  logic [13:0] en_l_s_S ;
  logic en_l_var;
  logic en_l_var_T ;
  logic en_l_var_R ;
  logic [13:0] en_l_var_S ;
  logic [31:0] i;
  logic [31:0] i_T ;
  logic [31:0] i_R ;
  logic [13:0] i_S ;
  input ld;
  input ld_T ;
  output ld_R ;
  input [13:0] ld_S ;
  output lz;
  logic lz ;
  output lz_T ;
  logic lz_T ;
  logic lz_R ;
  logic [13:0] lz_S ;
  input lz_R0 ;
  output [13:0] lz_S ;
  logic [32:0] n_elem;
  logic [32:0] n_elem_T ;
  logic [32:0] n_elem_R ;
  logic [13:0] n_elem_S ;
  output sd;
  logic sd ;
  output sd_T ;
  logic sd_T ;
  logic sd_R ;
  logic [13:0] sd_S ;
  input sd_R0 ;
  output [13:0] sd_S ;
  logic [32:0] size_t;
  logic [32:0] size_t_T ;
  logic [32:0] size_t_R ;
  logic [13:0] size_t_S ;
  input srst;
  input srst_T ;
  output srst_R ;
  input [13:0] srst_S ;
  logic stat;
  logic  stat_T ;
  logic  stat_PREV_VAL1 ;
  logic  stat_PREV_VAL2 ;
  logic  stat_R ;
  logic [13:0] stat_S ;
  logic stat_t_flag ;
  logic stat_r_flag ;
  assign stat_S = 8 ;
  logic stat_after;
  logic stat_after_T ;
  logic stat_after_R ;
  logic [13:0] stat_after_S ;
  logic stat_before;
  logic stat_before_T ;
  logic stat_before_R ;
  logic [13:0] stat_before_S ;
  logic stat_nxt;
  logic stat_nxt_T ;
  logic stat_nxt_R ;
  logic [13:0] stat_nxt_S ;
  logic stat_pre;
  logic stat_pre_T ;
  logic stat_pre_R ;
  logic [13:0] stat_pre_S ;
  output vd;
  logic vd ;
  output vd_T ;
  logic vd_T ;
  logic vd_R ;
  logic [13:0] vd_S ;
  input vd_R0 ;
  output [13:0] vd_S ;
  input vz;
  input vz_T ;
  output vz_R ;
  input [13:0] vz_S ;
  output [511:0] z;
  logic [511:0] z ;
  output [511:0] z_T ;
  logic [511:0] z_T ;
  logic [511:0] z_R ;
  logic [13:0] z_S ;
  input [511:0] z_R0 ;
  output [13:0] z_S ;
  assign sd = stat + \FIFO_REG.delta ;
  assign sd_S = 0 ;
  logic [0:0] stat_R0 ;
  logic [0:0] \FIFO_REG.delta_R0 ;
  assign sd_T = stat_T | \FIFO_REG.delta_T ;
  assign stat_R0 = sd_R ;
  assign \FIFO_REG.delta_R0 = sd_R ;
  assign _02_ = vz & stat;
  assign _02__S = 0 ;
  logic [0:0] vz_R0 ;
  logic [0:0] stat_R1 ;
  assign _02__T = ( vz_T & stat ) | ( stat_T & vz ) ;
  assign vz_R0 = _02__R & { 1{ stat != 0 }} ;
  assign stat_R1 = _02__R & { 1{ vz != 0 }} ;
  assign _03_ = stat & _07_;
  assign _03__S = 0 ;
  logic [0:0] stat_R2 ;
  logic [0:0] _07__R0 ;
  assign _03__T = ( stat_T & _07_ ) | ( _07__T & stat ) ;
  assign stat_R2 = _03__R & { 1{ _07_ != 0 }} ;
  assign _07__R0 = _03__R & { 1{ stat != 0 }} ;
  assign _04_ = stat & ld;
  assign _04__S = 0 ;
  logic [0:0] stat_R3 ;
  logic [0:0] ld_R0 ;
  assign _04__T = ( stat_T & ld ) | ( ld_T & stat ) ;
  assign stat_R3 = _04__R & { 1{ ld != 0 }} ;
  assign ld_R0 = _04__R & { 1{ stat != 0 }} ;
  assign _05_ = ld & _07_;
  assign _05__S = 0 ;
  logic [0:0] ld_R1 ;
  logic [0:0] _07__R1 ;
  assign _05__T = ( ld_T & _07_ ) | ( _07__T & ld ) ;
  assign ld_R1 = _05__R & { 1{ _07_ != 0 }} ;
  assign _07__R1 = _05__R & { 1{ ld != 0 }} ;
  assign en_l_var = ld & _08_;
  assign en_l_var_S = 0 ;
  logic [0:0] ld_R2 ;
  logic [0:0] _08__R0 ;
  assign en_l_var_T = ( ld_T & _08_ ) | ( _08__T & ld ) ;
  assign ld_R2 = en_l_var_R & { 1{ _08_ != 0 }} ;
  assign _08__R0 = en_l_var_R & { 1{ ld != 0 }} ;
  assign _06_ = ~ stat;
  logic [0:0] stat_R4 ;
  assign _06__T = stat_T ;
  assign stat_R4 = _06__R ;
  assign _06__S = 0 ;
  assign _07_ = ~ vz;
  logic [0:0] vz_R1 ;
  assign _07__T = vz_T ;
  assign vz_R1 = _07__R ;
  assign _07__S = 0 ;
  assign _08_ = ~ _03_;
  logic [0:0] _03__R0 ;
  assign _08__T = _03__T ;
  assign _03__R0 = _08__R ;
  assign _08__S = 0 ;
  assign _09_ = ~ active;
  logic [0:0] active_R0 ;
  assign _09__T = active_T ;
  assign active_R0 = _09__R ;
  assign _09__S = 0 ;
  assign _10_ = ~ en_l_var;
  logic [0:0] en_l_var_R0 ;
  assign _10__T = en_l_var_T ;
  assign en_l_var_R0 = _10__R ;
  assign _10__S = 0 ;
  assign active = ld | vz;
  assign active_S = 0 ;
  logic [0:0] ld_R3 ;
  logic [0:0] vz_R2 ;
  assign active_T = ( ld_T & ~vz ) | ( vz_T & ~ld ) ;
  assign ld_R3 = active_R & { 1{ vz != 1'b1 }} ;
  assign vz_R2 = active_R & { 1{ ld != 1'b1 }} ;
  assign vd = vz | _06_;
  assign vd_S = 0 ;
  logic [0:0] vz_R3 ;
  logic [0:0] _06__R0 ;
  assign vd_T = ( vz_T & ~_06_ ) | ( _06__T & ~vz ) ;
  assign vz_R3 = vd_R & { 1{ _06_ != 1'b1 }} ;
  assign _06__R0 = vd_R & { 1{ vz != 1'b1 }} ;
  assign lz = ld | stat;
  assign lz_S = 0 ;
  logic [0:0] ld_R4 ;
  logic [0:0] stat_R5 ;
  assign lz_T = ( ld_T & ~stat ) | ( stat_T & ~ld ) ;
  assign ld_R4 = lz_R & { 1{ stat != 1'b1 }} ;
  assign stat_R5 = lz_R & { 1{ ld != 1'b1 }} ;
  assign _11_ = _03_ | _04_;
  assign _11__S = 0 ;
  logic [0:0] _03__R1 ;
  logic [0:0] _04__R0 ;
  assign _11__T = ( _03__T & ~_04_ ) | ( _04__T & ~_03_ ) ;
  assign _03__R1 = _11__R & { 1{ _04_ != 1'b1 }} ;
  assign _04__R0 = _11__R & { 1{ _03_ != 1'b1 }} ;
  assign stat_pre = _11_ | _05_;
  assign stat_pre_S = 0 ;
  logic [0:0] _11__R0 ;
  logic [0:0] _05__R0 ;
  assign stat_pre_T = ( _11__T & ~_05_ ) | ( _05__T & ~_11_ ) ;
  assign _11__R0 = stat_pre_R & { 1{ _05_ != 1'b1 }} ;
  assign _05__R0 = stat_pre_R & { 1{ _11_ != 1'b1 }} ;
  assign en_l_s = en | _09_;
  assign en_l_s_S = 0 ;
  logic [0:0] en_R0 ;
  logic [0:0] _09__R0 ;
  assign en_l_s_T = ( en_T & ~_09_ ) | ( _09__T & ~en ) ;
  assign en_R0 = en_l_s_R & { 1{ _09_ != 1'b1 }} ;
  assign _09__R0 = en_l_s_R & { 1{ en != 1'b1 }} ;
  assign en_l = en | _10_;
  assign en_l_S = 0 ;
  logic [0:0] en_R1 ;
  logic [0:0] _10__R0 ;
  assign en_l_T = ( en_T & ~_10_ ) | ( _10__T & ~en ) ;
  assign en_R1 = en_l_R & { 1{ _10_ != 1'b1 }} ;
  assign _10__R0 = en_l_R & { 1{ en != 1'b1 }} ;
  always @(posedge clk or negedge arst)
    if (!arst)
      buff <= 512'b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    else
      buff <= _00_;
  logic [511:0] _00__R0 ;
  assign _00__R0 = _00__T & { 512{ buff_S != _00__S }} ;
  always @( posedge clk )
      buff_T 		<= !arst ? 0 : ( _00__T & ( buff_T | { 512{ buff_S != _00__S }} ));
  always @( posedge clk )
      buff_t_flag 	<= !arst ? 0 : buff_t_flag ? 1 : | _00__T & ( buff_S != _00__S );
  always @( posedge clk )
      buff_r_flag 	<= !arst ? 0 : buff_r_flag ? 1 : buff_t_flag ? 0 : ( (| buff_R ) && (buff != 0) ) ;
  always @(posedge clk or negedge arst)
    if (!arst)
      stat <= 1'b0;
    else
      stat <= _01_;
  logic [0:0] _01__R0 ;
  assign _01__R0 = _01__T & { 1{ stat_S != _01__S }} ;
  always @( posedge clk )
      stat_T 		<= !arst ? 0 : ( _01__T & ( stat_T | { 1{ stat_S != _01__S }} ));
  always @( posedge clk )
      stat_t_flag 	<= !arst ? 0 : stat_t_flag ? 1 : | _01__T & ( stat_S != _01__S );
  always @( posedge clk )
      stat_r_flag 	<= !arst ? 0 : stat_r_flag ? 1 : stat_t_flag ? 0 : ( (| stat_R ) && (stat != 0) ) ;
  assign _12_ = en_l ? buff : d;
  logic [0:0] en_l_R0 ;
  assign en_l_R0 = ( | _12__R ) && buff != d ;
  assign _12__T = en_l ? ( { 512{ en_l_T  }} | buff_T ) : ( { 512{ en_l_T  }} | d_T );
  assign _12__S = en_l ? buff_S : d_S ;
  logic [511:0] buff_R0 ;
  assign buff_R0 = { 512{ en_l }} & ( _12__R );
  logic [511:0] d_R0 ;
  assign d_R0 = { 512{ !en_l }} & ( _12__R );
  assign _00_ = srst ? _12_ : 512'b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  logic [0:0] srst_R0 ;
  assign srst_R0 = ( | _00__R ) && _12_ != 512'b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 ;
  logic [511:0] _12__R0 ;
  assign _12__R0 = { 512{ srst }} & ( _00__R );
  assign _00__T = srst ? ( { 512{ | srst_T  }} | _12__T ) : { 512{ | srst_T  }};
  assign _00__S = srst ? _12__S : 0 ;
  assign _13_ = en_l_s ? stat : stat_pre;
  logic [0:0] en_l_s_R0 ;
  assign en_l_s_R0 = ( | _13__R ) && stat != stat_pre ;
  assign _13__T = en_l_s ? ( { 1{ en_l_s_T  }} | stat_T ) : ( { 1{ en_l_s_T  }} | stat_pre_T );
  assign _13__S = en_l_s ? stat_S : stat_pre_S ;
  logic [0:0] stat_R6 ;
  assign stat_R6 = { 1{ en_l_s }} & ( _13__R );
  logic [0:0] stat_pre_R0 ;
  assign stat_pre_R0 = { 1{ !en_l_s }} & ( _13__R );
  assign _01_ = srst ? _13_ : 1'b0;
  logic [0:0] srst_R1 ;
  assign srst_R1 = ( | _01__R ) && _13_ != 1'b0 ;
  logic [0:0] _13__R0 ;
  assign _13__R0 = { 1{ srst }} & ( _01__R );
  assign _01__T = srst ? ( { 1{ | srst_T  }} | _13__T ) : { 1{ | srst_T  }};
  assign _01__S = srst ? _13__S : 0 ;
  assign z = stat ? buff : d;
  logic [0:0] stat_R7 ;
  assign stat_R7 = ( | z_R ) && buff != d ;
  assign z_T = stat ? ( { 512{ stat_T  }} | buff_T ) : ( { 512{ stat_T  }} | d_T );
  assign z_S = stat ? buff_S : d_S ;
  logic [511:0] buff_R1 ;
  assign buff_R1 = { 512{ stat }} & ( z_R );
  logic [511:0] d_R1 ;
  assign d_R1 = { 512{ !stat }} & ( z_R );
  assign \FIFO_REG.delta = _02_ ^ ld;
  assign \FIFO_REG.delta_S = 0 ;
  logic [0:0] _02__R0 ;
  logic [0:0] ld_R5 ;
  assign \FIFO_REG.delta_T = _02__T | ld_T ;
  assign _02__R0 = \FIFO_REG.delta_R ;
  assign ld_R5 = \FIFO_REG.delta_R ;
  assign buff_nxt = d;
  logic [511:0] d_R2 ;
  assign buff_nxt_T = d_T ;
  assign d_R2 = buff_nxt_R ;
  assign buff_nxt_S = d_S ;
  assign buff_pre = d;
  logic [511:0] d_R3 ;
  assign buff_pre_T = d_T ;
  assign d_R3 = buff_pre_R ;
  assign buff_pre_S = d_S ;
  assign count = stat;
  logic [0:0] stat_R8 ;
  assign count_T = stat_T ;
  assign stat_R8 = count_R ;
  assign count_S = stat_S ;
  assign count_t = { 31'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, stat };
  assign count_t_T = {  31'h0 , stat_T  };
  logic [13:0] count_t_S ;
  assign count_t_S = 0 ;
  logic [0:0] stat_R9 ;
  assign stat_R9 = count_t_R [0:0] ;
  assign i = 32'd4294967295;
  assign i_T = 0 ;
  assign i_S = 14'b1 ;
  assign n_elem = 33'b000000000000000000000000000000000;
  assign n_elem_T = 0 ;
  assign n_elem_S = 14'b1 ;
  assign size_t[0] = sd;
  logic [0:0] sd_R1 ;
  assign size_t_T [0] = sd_T ;
  assign sd_R1 = size_t_R [0] ;
  assign size_t_S = sd_S ;
  assign stat_after = 1'b1;
  assign stat_after_T = 0 ;
  assign stat_after_S = 14'b1 ;
  assign stat_before = 1'b0;
  assign stat_before_T = 0 ;
  assign stat_before_S = 14'b1 ;
  assign stat_nxt = stat_pre;
  logic [0:0] stat_pre_R1 ;
  assign stat_nxt_T = stat_pre_T ;
  assign stat_pre_R1 = stat_nxt_R ;
  assign stat_nxt_S = stat_pre_S ;
  assign _13__R = ( _13__R0 );
  assign stat_pre_R = ( stat_pre_R0 ) | ( stat_pre_R1 );
  assign en_l_s_R = ( en_l_s_R0 );
  assign _12__R = ( _12__R0 );
  assign d_R = ( d_R0 ) | ( d_R1 ) | ( d_R2 ) | ( d_R3 );
  assign buff_R = ( buff_R0 ) | ( buff_R1 );
  assign en_l_R = ( en_l_R0 );
  assign _01__R = ( _01__R0 );
  assign _00__R = ( _00__R0 );
  assign _02__R = ( _02__R0 );
  assign _10__R = ( _10__R0 );
  assign _09__R = ( _09__R0 );
  assign en_R = ( en_R0 ) | ( en_R1 );
  assign _05__R = ( _05__R0 );
  assign _11__R = ( _11__R0 );
  assign _04__R = ( _04__R0 );
  assign _06__R = ( _06__R0 );
  assign srst_R = ( srst_R0 ) | ( srst_R1 );
  assign en_l_var_R = ( en_l_var_R0 );
  assign active_R = ( active_R0 );
  assign _03__R = ( _03__R0 ) | ( _03__R1 );
  assign _08__R = ( _08__R0 );
  assign ld_R = ( ld_R0 ) | ( ld_R1 ) | ( ld_R2 ) | ( ld_R3 ) | ( ld_R4 ) | ( ld_R5 );
  assign _07__R = ( _07__R0 ) | ( _07__R1 );
  assign vz_R = ( vz_R0 ) | ( vz_R1 ) | ( vz_R2 ) | ( vz_R3 );
  assign \FIFO_REG.delta_R = ( \FIFO_REG.delta_R0 );
  assign stat_R = ( stat_R0 ) | ( stat_R1 ) | ( stat_R2 ) | ( stat_R3 ) | ( stat_R4 ) | ( stat_R5 ) | ( stat_R6 ) | ( stat_R7 ) | ( stat_R8 ) | ( stat_R9 );
  assign z_R = ( z_R0 );
  assign vd_R = ( vd_R0 );
  assign sd_R = ( sd_R0 ) | ( sd_R1 );
  assign lz_R = ( lz_R0 );
 // ground taints for floating regs
 // ground taints for unused wires
  assign { buff_nxt_R , buff_pre_R , count_R , count_t_R , i_R , n_elem_R , size_t_R , stat_after_R , stat_before_R , stat_nxt_R , arst_R , clk_R  } = 0;
  always @( posedge clk ) begin
    if( !arst ) buff_PREV_VAL1 <= 0 ;
    if( !arst ) buff_PREV_VAL2 <= 0 ;
    if( INSTR_IN_ZY ) buff_PREV_VAL1 <= buff ;
    if( INSTR_IN_ZY ) buff_PREV_VAL2 <= buff_PREV_VAL1 ;
  end
  always @( posedge clk ) begin
    if( !arst ) stat_PREV_VAL1 <= 0 ;
    if( !arst ) stat_PREV_VAL2 <= 0 ;
    if( INSTR_IN_ZY ) stat_PREV_VAL1 <= stat ;
    if( INSTR_IN_ZY ) stat_PREV_VAL2 <= stat_PREV_VAL1 ;
  end
 // ground taints for unused wire slices
  assert property( buff_r_flag == 0 );
  assert property( stat_r_flag == 0 );
  assign rst_zy = !arst ;
endmodule
