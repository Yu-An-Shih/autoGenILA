  output [799:0] d;
  logic [799:0] d ;
  output [799:0] d_T ;
  logic [799:0] d_T ;
  logic [799:0] d_R ;
  logic [799:0] d_C ;
  logic [799:0] d_X ;
  logic [13:0] d_S ;
  input [799:0] d_R0 ;
  input [799:0] d_C0 ;
  input [799:0] d_X0 ;
  output [13:0] d_S ;
  input ld;
  input ld_T ;
  input [13:0] ld_S ;
  output ld_R ;
  output ld_X ;
  output ld_C ;
  output lz;
  logic lz ;
  output lz_T ;
  logic lz_T ;
  logic lz_R ;
  logic lz_C ;
  logic lz_X ;
  logic [13:0] lz_S ;
  input lz_R0 ;
  input lz_C0 ;
  input lz_X0 ;
  output [13:0] lz_S ;
  output sd;
  logic sd ;
  output sd_T ;
  logic sd_T ;
  logic sd_R ;
  logic sd_C ;
  logic sd_X ;
  logic [13:0] sd_S ;
  input sd_R0 ;
  input sd_C0 ;
  input sd_X0 ;
  output [13:0] sd_S ;
  input sld;
  input sld_T ;
  input [13:0] sld_S ;
  output sld_R ;
  output sld_X ;
  output sld_C ;
  output slz;
  logic slz ;
  output slz_T ;
  logic slz_T ;
  logic slz_R ;
  logic slz_C ;
  logic slz_X ;
  logic [13:0] slz_S ;
  input slz_R0 ;
  input slz_C0 ;
  input slz_X0 ;
  output [13:0] slz_S ;
  input sz;
  input sz_T ;
  input [13:0] sz_S ;
  output sz_R ;
  output sz_X ;
  output sz_C ;
  output vd;
  logic vd ;
  output vd_T ;
  logic vd_T ;
  logic vd_R ;
  logic vd_C ;
  logic vd_X ;
  logic [13:0] vd_S ;
  input vd_R0 ;
  input vd_C0 ;
  input vd_X0 ;
  output [13:0] vd_S ;
  input vz;
  input vz_T ;
  input [13:0] vz_S ;
  output vz_R ;
  output vz_X ;
  output vz_C ;
  input [799:0] z;
  input [799:0] z_T ;
  input [13:0] z_S ;
  output [799:0] z_R ;
  output [799:0] z_X ;
  output [799:0] z_C ;
  assign d = z;
  logic [799:0] z_C0 ;
  logic [799:0] z_R0 ;
  logic [799:0] z_X0 ;
  assign d_T = z_T ;
  assign z_C0 = d_C ;
  assign z_R0 = d_R ;
  assign z_X0 = d_X ;
  assign d_S = z_S ;
  assign lz = ld;
  logic [0:0] ld_C0 ;
  logic [0:0] ld_R0 ;
  logic [0:0] ld_X0 ;
  assign lz_T = ld_T ;
  assign ld_C0 = lz_C ;
  assign ld_R0 = lz_R ;
  assign ld_X0 = lz_X ;
  assign lz_S = ld_S ;
  assign sd = sz;
  logic [0:0] sz_C0 ;
  logic [0:0] sz_R0 ;
  logic [0:0] sz_X0 ;
  assign sd_T = sz_T ;
  assign sz_C0 = sd_C ;
  assign sz_R0 = sd_R ;
  assign sz_X0 = sd_X ;
  assign sd_S = sz_S ;
  assign slz = sld;
  logic [0:0] sld_C0 ;
  logic [0:0] sld_R0 ;
  logic [0:0] sld_X0 ;
  assign slz_T = sld_T ;
  assign sld_C0 = slz_C ;
  assign sld_R0 = slz_R ;
  assign sld_X0 = slz_X ;
  assign slz_S = sld_S ;
  assign vd = vz;
  logic [0:0] vz_C0 ;
  logic [0:0] vz_R0 ;
  logic [0:0] vz_X0 ;
  assign vd_T = vz_T ;
  assign vz_C0 = vd_C ;
  assign vz_R0 = vd_R ;
  assign vz_X0 = vd_X ;
  assign vd_S = vz_S ;
  assign vz_C = ( vz_C0 );
  assign sld_C = ( sld_C0 );
  assign sz_C = ( sz_C0 );
  assign ld_C = ( ld_C0 );
  assign z_C = ( z_C0 );
  assign vd_C = ( vd_C0 );
  assign slz_C = ( slz_C0 );
  assign sd_C = ( sd_C0 );
  assign lz_C = ( lz_C0 );
  assign d_C = ( d_C0 );
  assign vz_X = ( vz_X0 );
  assign sld_X = ( sld_X0 );
  assign sz_X = ( sz_X0 );
  assign ld_X = ( ld_X0 );
  assign z_X = ( z_X0 );
  assign vd_X = ( vd_X0 );
  assign slz_X = ( slz_X0 );
  assign sd_X = ( sd_X0 );
  assign lz_X = ( lz_X0 );
  assign d_X = ( d_X0 );
  assign vz_R = ( vz_X0 & vz_R0 );
  assign sld_R = ( sld_X0 & sld_R0 );
  assign sz_R = ( sz_X0 & sz_R0 );
  assign ld_R = ( ld_X0 & ld_R0 );
  assign z_R = ( z_X0 & z_R0 );
  assign vd_R = ( vd_X0 & vd_R0 );
  assign slz_R = ( slz_X0 & slz_R0 );
  assign sd_R = ( sd_X0 & sd_R0 );
  assign lz_R = ( lz_X0 & lz_R0 );
  assign d_R = ( d_X0 & d_R0 );
 // ground taints for floating regs
 // ground taints for unused wires
 // ground taints for unused wire slices
endmodule
