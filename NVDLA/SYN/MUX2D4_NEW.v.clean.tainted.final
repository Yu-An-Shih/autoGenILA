module MUX2D4 ( I0 , I1 , S , INSTR_IN_ZY , rst_zy , I0_T , I0_S , I1_T , I1_S , S_T , S_S , Z_R0 , Z_C0 , Z_X0 , Z , I0_R , I0_X , I0_C , I1_R , I1_X , I1_C , S_R , S_X , S_C , Z_T , Z_S );
  input rst_zy;
  integer i;
  input INSTR_IN_ZY;
  input I0;
  input I0_T ;
  input [13:0] I0_S ;
  output I0_R ;
  output I0_X ;
  output I0_C ;
  input I1;
  input I1_T ;
  input [13:0] I1_S ;
  output I1_R ;
  output I1_X ;
  output I1_C ;
  input S;
  input S_T ;
  input [13:0] S_S ;
  output S_R ;
  output S_X ;
  output S_C ;
  output Z;
  logic Z ;
  output Z_T ;
  logic Z_T ;
  logic Z_R ;
  logic Z_C ;
  logic Z_X ;
  logic [13:0] Z_S ;
  input Z_R0 ;
  input Z_C0 ;
  input Z_X0 ;
  output [13:0] Z_S ;
  assign Z = S ? I1 : I0;
  logic [0:0] S_C0 ;
  logic [0:0] S_R0 ;
  logic [0:0] S_X0 ;
  assign S_C0 = | Z_C ;
  assign S_X0 = | Z_X ;
  assign Z_T = S ? ( { 1{ S_T  }} | I1_T ) : ( { 1{ S_T  }} | I0_T );
  assign Z_S = S ? I1_S : I0_S ;
  assign S_R0 = ( | (Z_R | ( Z_C & ( { 1{ S }} & I1_T | { 1{ !S }} & I0_T )))) && I1 != I0 ;
  logic [0:0] I1_C0 ;
  logic [0:0] I1_R0 ;
  logic [0:0] I1_X0 ;
  assign I1_C0 = { 1{ S }} ;
  assign I1_R0 = { 1{ S }} & ( Z_R | ( { 1{ S_T  }} & Z_C ));
  assign I1_X0 = { 1{ S }} & Z_X ;
  logic [0:0] I0_C0 ;
  logic [0:0] I0_R0 ;
  logic [0:0] I0_X0 ;
  assign I0_C0 = { 1{ !S }} ;
  assign I0_R0 = { 1{ !S }} & ( Z_R | ( { 1{ S_T  }} & Z_C ));
  assign I0_X0 = { 1{ !S }} & Z_X ;
  assign I0_C = ( I0_C0 );
  assign I1_C = ( I1_C0 );
  assign S_C = ( S_C0 );
  assign Z_C = ( Z_C0 );
  assign I0_X = ( I0_X0 );
  assign I1_X = ( I1_X0 );
  assign S_X = ( S_X0 );
  assign Z_X = ( Z_X0 );
  assign I0_R = ( I0_X0 & I0_R0 );
  assign I1_R = ( I1_X0 & I1_R0 );
  assign S_R = ( S_X0 & S_R0 );
  assign Z_R = ( Z_X0 & Z_R0 );
 // ground taints for floating regs
 // ground taints for unused wires
 // ground taints for unused wire slices
endmodule
