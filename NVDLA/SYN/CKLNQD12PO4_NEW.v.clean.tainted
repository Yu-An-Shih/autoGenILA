  logic _0_;
  logic _0__T ;
  logic _0__R ;
  logic _0__C ;
  logic _0__X ;
  logic [13:0] _0__S ;
  input CP;
  input CP_T ;
  input [13:0] CP_S ;
  output CP_R ;
  output CP_X ;
  output CP_C ;
  input E;
  input E_T ;
  input [13:0] E_S ;
  output E_R ;
  output E_X ;
  output E_C ;
  output Q;
  logic Q ;
  output Q_T ;
  logic Q_T ;
  logic Q_R ;
  logic Q_C ;
  logic Q_X ;
  logic [13:0] Q_S ;
  input Q_R0 ;
  input Q_C0 ;
  input Q_X0 ;
  output [13:0] Q_S ;
  input TE;
  input TE_T ;
  input [13:0] TE_S ;
  output TE_R ;
  output TE_X ;
  output TE_C ;
  logic qd;
  logic  qd_T ;
  logic  qd_PREV_VAL1 ;
  logic  qd_PREV_VAL2 ;
  logic  qd_R ;
  logic  qd_X ;
  logic  qd_C ;
  logic [13:0] qd_S ;
  logic qd_t_flag ;
  logic qd_r_flag ;
  assign qd_S = 12 ;
  assign Q = CP & qd;
  assign Q_S = 0 ;
  logic [0:0] CP_C0 ;
  logic [0:0] CP_R0 ;
  logic [0:0] CP_X0 ;
  logic [0:0] qd_C0 ;
  logic [0:0] qd_R0 ;
  logic [0:0] qd_X0 ;
  assign Q_T = CP_T | qd_T ;
  assign CP_C0 = Q_C ;
  assign CP_X0 = Q_X ;
  assign qd_C0 = Q_C ;
  assign qd_X0 = Q_X ;
  assign CP_R0 = ( Q_R | Q_C & qd_T ) & { 1{ qd != 0 }} ;
  assign qd_R0 = ( Q_R | Q_C & CP_T ) & { 1{ CP != 0 }} ;
  assign _0_ = TE | E;
  assign _0__S = 0 ;
  logic [0:0] TE_C0 ;
  logic [0:0] TE_R0 ;
  logic [0:0] TE_X0 ;
  logic [0:0] E_C0 ;
  logic [0:0] E_R0 ;
  logic [0:0] E_X0 ;
  assign _0__T = TE_T | E_T ;
  assign TE_C0 = _0__C ;
  assign TE_X0 = _0__X ;
  assign E_C0 = _0__C ;
  assign E_X0 = _0__X ;
  assign TE_R0 = ( _0__R | _0__C & E_T ) & { 1{ E != 1'b1 }} ;
  assign E_R0 = ( _0__R | _0__C & TE_T ) & { 1{ TE != 1'b1 }} ;
  always @(negedge CP)
      qd <= _0_;
  assign qd_T = 0;
  assign qd_r_flag = 0;
  assign qd_t_flag = 0;
  assign E_C = ( E_C0 );
  assign TE_C = ( TE_C0 );
  assign qd_C = ( qd_C0 );
  assign CP_C = ( CP_C0 );
  assign Q_C = ( Q_C0 );
  assign E_X = ( E_X0 );
  assign TE_X = ( TE_X0 );
  assign qd_X = ( qd_X0 );
  assign CP_X = ( CP_X0 );
  assign Q_X = ( Q_X0 );
  assign E_R = ( E_X0 & E_R0 );
  assign TE_R = ( TE_X0 & TE_R0 );
  assign qd_R = ( qd_X0 & qd_R0 );
  assign CP_R = ( CP_X0 & CP_R0 );
  assign Q_R = ( Q_X0 & Q_R0 );
 // ground taints for floating regs
 // ground taints for unused wires
  assign { _0__R , _0__C , _0__X  } = 0;
  always @( posedge  ) begin
    if( rst_zy ) qd_PREV_VAL1 <= 0 ;
    if( rst_zy ) qd_PREV_VAL2 <= 0 ;
    if( INSTR_IN_ZY ) qd_PREV_VAL1 <= qd ;
    if( INSTR_IN_ZY ) qd_PREV_VAL2 <= qd_PREV_VAL1 ;
  end
 // ground taints for unused wire slices
  assert property( qd_r_flag == 0 || qd_PREV_VAL1 == qd_PREV_VAL2 );
endmodule
