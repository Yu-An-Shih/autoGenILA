  logic [31:0] _000_;
  logic [31:0] _001_;
  logic [31:0] _002_;
  logic [31:0] _003_;
  logic [31:0] _004_;
  logic [31:0] _005_;
  logic [31:0] _006_;
  logic [31:0] _007_;
  logic [31:0] _008_;
  logic _009_;
  logic [31:0] _010_;
  logic [6:0] _011_;
  logic [1:0] _012_;
  logic [30:0] _013_;
  logic [31:0] _014_;
  logic [31:0] _015_;
  logic [28:0] _016_;
  logic [31:0] _017_;
  logic [31:0] _018_;
  logic [31:0] _019_;
  logic [31:0] _020_;
  logic [31:0] _021_;
  logic [31:0] _022_;
  logic [31:0] _023_;
  logic [31:0] _024_;
  logic [31:0] _025_;
  logic [31:0] _026_;
  logic [31:0] _027_;
  logic [31:0] _028_;
  logic [31:0] _029_;
  logic _030_;
  logic [31:0] _031_;
  logic [31:0] _032_;
  logic [31:0] _033_;
  logic [31:0] _034_;
  logic [1:0] _035_;
  logic _036_;
  logic [31:0] _037_;
  logic [31:0] _038_;
  logic [31:0] _039_;
  logic [31:0] _040_;
  logic [31:0] _041_;
  logic [31:0] _042_;
  logic [31:0] _043_;
  logic [31:0] _044_;
  logic [31:0] _045_;
  logic [31:0] _046_;
  logic [31:0] _047_;
  logic [6:0] _048_;
  logic [31:0] _049_;
  logic [31:0] _050_;
  logic _051_;
  logic _052_;
  logic _053_;
  logic _054_;
  logic _055_;
  logic _056_;
  logic _057_;
  logic _058_;
  logic [31:0] _059_;
  logic [31:0] _060_;
  logic [31:0] _061_;
  logic [31:0] _062_;
  logic [1:0] _063_;
  logic _064_;
  logic [6:0] _065_;
  logic [31:0] _066_;
  logic [31:0] _067_;
  logic [31:0] _068_;
  logic [31:0] _069_;
  logic [31:0] _070_;
  logic [31:0] _071_;
  logic [31:0] _072_;
  logic [31:0] _073_;
  logic [31:0] _074_;
  logic [31:0] _075_;
  logic [31:0] _076_;
  logic [31:0] _077_;
  logic [31:0] _078_;
  logic [31:0] _079_;
  logic [31:0] _080_;
  logic [31:0] H0_new;
  logic [31:0] H0_reg;
  logic [31:0]  H0_reg_PREV_VAL1 ;
  logic [31:0] H1_new;
  logic [31:0] H1_reg;
  logic [31:0]  H1_reg_PREV_VAL1 ;
  logic [31:0] H2_new;
  logic [31:0] H2_reg;
  logic [31:0]  H2_reg_PREV_VAL1 ;
  logic [31:0] H3_new;
  logic [31:0] H3_reg;
  logic [31:0]  H3_reg_PREV_VAL1 ;
  logic [31:0] H4_new;
  logic [31:0] H4_reg;
  logic [31:0]  H4_reg_PREV_VAL1 ;
  logic H_we;
  logic a_e_we;
  logic [31:0] a_new;
  logic [31:0] a_reg;
  logic [31:0]  a_reg_PREV_VAL1 ;
  logic [31:0] b_new;
  logic [31:0] b_reg;
  logic [31:0]  b_reg_PREV_VAL1 ;
  input [511:0] block;
  logic [31:0] c_new;
  logic [31:0] c_reg;
  logic [31:0]  c_reg_PREV_VAL1 ;
  input clk;
  logic [31:0] d_new;
  logic [31:0] d_reg;
  logic [31:0]  d_reg_PREV_VAL1 ;
  output [159:0] digest;
  logic [159:0] digest ;
  logic digest_init;
  logic digest_update;
  output digest_valid;
  logic digest_valid ;
  logic digest_valid_new;
  logic digest_valid_reg;
  logic  digest_valid_reg_PREV_VAL1 ;
  logic digest_valid_we;
  logic [31:0] e_new;
  logic [31:0] e_reg;
  logic [31:0]  e_reg_PREV_VAL1 ;
  logic first_block;
  input init;
  input next;
  output ready;
  logic ready ;
  logic ready_flag;
  input reset_n;
  logic round_ctr_inc;
  logic [6:0] round_ctr_new;
  logic [6:0] round_ctr_reg;
  logic [6:0]  round_ctr_reg_PREV_VAL1 ;
  logic round_ctr_rst;
  logic round_ctr_we;
  logic [1:0] sha1_ctrl_new;
  logic [1:0] sha1_ctrl_reg;
  logic [1:0]  sha1_ctrl_reg_PREV_VAL1 ;
  logic sha1_ctrl_we;
  logic state_init;
  logic state_update;
  logic [31:0] w;
  logic w_init;
  logic w_next;
  assign _039_ = H0_reg + a_reg;
  assign _040_ = H1_reg + b_reg;
  assign _041_ = H2_reg + c_reg;
  assign _042_ = H3_reg + d_reg;
  assign _043_ = H4_reg + e_reg;
  logic [31:0] fangyuan0;
  assign fangyuan0 = { a_reg[26:0], a_reg[31:27] };
  assign _044_ = fangyuan0 + e_reg;
  assign _045_ = _044_ + _028_;
  assign _046_ = _045_ + _029_;
  assign _047_ = _046_ + w;
  assign _048_ = round_ctr_reg + 1'b1;
  assign _049_ = b_reg & c_reg;
  assign _050_ = _059_ & d_reg;
  assign _036_ = round_ctr_reg == 7'b1001111;
  assign _051_ = round_ctr_reg >= 5'b10100;
  assign _052_ = round_ctr_reg >= 6'b101000;
  assign _053_ = round_ctr_reg >= 6'b111100;
  assign _054_ = round_ctr_reg <= 5'b10011;
  assign _055_ = round_ctr_reg <= 6'b100111;
  assign _056_ = round_ctr_reg <= 6'b111011;
  assign _057_ = _051_ && _055_;
  assign _058_ = _052_ && _056_;
  assign _059_ = ~ b_reg;
  assign _060_ = b_reg | c_reg;
  assign _061_ = b_reg | d_reg;
  assign _062_ = c_reg | d_reg;
  always @(posedge clk)
      a_reg <= _005_;
  always @(posedge clk)
      b_reg <= _006_;
  always @(posedge clk)
      c_reg <= _007_;
  always @(posedge clk)
      d_reg <= _008_;
  always @(posedge clk)
      e_reg <= _010_;
  always @(posedge clk)
      H0_reg <= _000_;
  always @(posedge clk)
      H1_reg <= _001_;
  always @(posedge clk)
      H2_reg <= _002_;
  always @(posedge clk)
      H3_reg <= _003_;
  always @(posedge clk)
      H4_reg <= _004_;
  always @(posedge clk)
      round_ctr_reg <= _011_;
  always @(posedge clk)
      digest_valid_reg <= _009_;
  always @(posedge clk)
      sha1_ctrl_reg <= _012_;
  assign round_ctr_inc = sha1_ctrl_reg == 1'b1;
  assign _035_ = _036_ ? 2'b10 : 2'b00;
  assign ready = ! sha1_ctrl_reg;
  assign _030_ = next ? 1'b1 : init;
  logic [2:0] fangyuan1;
  assign fangyuan1 = { _030_, _036_, 1'b1 };
  logic [2:0] fangyuan2;
  assign fangyuan2 = { ready, round_ctr_inc, digest_update };
  always @(1'b0 or fangyuan1 or fangyuan2) begin
    casez (fangyuan2)
      3'b??1 :
        sha1_ctrl_we = fangyuan1 [0:0] ;
      3'b?1? :
        sha1_ctrl_we = fangyuan1 [1:1] ;
      3'b1?? :
        sha1_ctrl_we = fangyuan1 [2:2] ;
      default:
        sha1_ctrl_we = 1'b0 ;
    endcase
  end
  assign digest_update = sha1_ctrl_reg == 2'b10;
  logic [3:0] fangyuan3;
  assign fangyuan3 = { 1'b0, _030_, _035_ };
  logic [1:0] fangyuan4;
  assign fangyuan4 = { ready, round_ctr_inc };
  always @(2'b00 or fangyuan3 or fangyuan4) begin
    casez (fangyuan4)
      2'b?1 :
        sha1_ctrl_new = fangyuan3 [1:0] ;
      2'b1? :
        sha1_ctrl_new = fangyuan3 [3:2] ;
      default:
        sha1_ctrl_new = 2'b00 ;
    endcase
  end
  logic [1:0] fangyuan5;
  assign fangyuan5 = { _030_, 1'b1 };
  logic [1:0] fangyuan6;
  assign fangyuan6 = { ready, digest_update };
  always @(1'b0 or fangyuan5 or fangyuan6) begin
    casez (fangyuan6)
      2'b?1 :
        digest_valid_we = fangyuan5 [0:0] ;
      2'b1? :
        digest_valid_we = fangyuan5 [1:1] ;
      default:
        digest_valid_we = 1'b0 ;
    endcase
  end
  assign round_ctr_rst = ready ? _030_ : 1'b0;
  assign digest_init = ready ? init : 1'b0;
  assign a_e_we = round_ctr_inc ? 1'b1 : round_ctr_rst;
  assign round_ctr_new = round_ctr_inc ? _048_ : 7'b0000000;
  assign _037_ = _053_ ? _078_ : 32'd0;
  assign _038_ = _053_ ? 32'd3395469782 : 32'd0;
  assign _033_ = _058_ ? _080_ : _037_;
  assign _034_ = _058_ ? 32'd2400959708 : _038_;
  assign _031_ = _057_ ? _078_ : _033_;
  assign _032_ = _057_ ? 32'd1859775393 : _034_;
  assign _028_ = _054_ ? _076_ : _031_;
  assign _029_ = _054_ ? 32'd1518500249 : _032_;
  assign e_new = round_ctr_inc ? d_reg : _022_;
  assign d_new = round_ctr_inc ? c_reg : _021_;
  logic [31:0] fangyuan7;
  assign fangyuan7 = { b_reg[1:0], b_reg[31:2] };
  assign c_new = round_ctr_inc ? fangyuan7 : _020_;
  assign b_new = round_ctr_inc ? a_reg : _019_;
  assign a_new = round_ctr_inc ? _047_ : _018_;
  assign _027_ = digest_init ? 32'd3285377520 : H4_reg;
  assign _026_ = digest_init ? 32'd271733878 : H3_reg;
  assign _025_ = digest_init ? 32'd2562383102 : H2_reg;
  assign _024_ = digest_init ? 32'd4023233417 : H1_reg;
  assign _023_ = digest_init ? 32'd1732584193 : H0_reg;
  assign _022_ = round_ctr_rst ? _027_ : 32'd0;
  assign _021_ = round_ctr_rst ? _026_ : 32'd0;
  assign _020_ = round_ctr_rst ? _025_ : 32'd0;
  assign _019_ = round_ctr_rst ? _024_ : 32'd0;
  assign _018_ = round_ctr_rst ? _023_ : 32'd0;
  assign H_we = digest_update ? 1'b1 : digest_init;
  assign H4_new = digest_update ? _043_ : _017_;
  logic [31:0] fangyuan8;
  assign fangyuan8 = { 3'b000, _016_ };
  assign H3_new = digest_update ? _042_ : fangyuan8;
  assign H2_new = digest_update ? _041_ : _015_;
  assign H1_new = digest_update ? _040_ : _014_;
  logic [31:0] fangyuan9;
  assign fangyuan9 = { 1'b0, _013_ };
  assign H0_new = digest_update ? _039_ : fangyuan9;
  assign _017_ = digest_init ? 32'd3285377520 : 32'd0;
  assign _016_ = digest_init ? 29'b10000001100100101010001110110 : 29'b00000000000000000000000000000;
  assign _015_ = digest_init ? 32'd2562383102 : 32'd0;
  assign _014_ = digest_init ? 32'd4023233417 : 32'd0;
  assign _013_ = digest_init ? 31'b1100111010001010010001100000001 : 31'b0000000000000000000000000000000;
  assign _063_ = sha1_ctrl_we ? sha1_ctrl_new : sha1_ctrl_reg;
  assign _012_ = reset_n ? _063_ : 2'b00;
  assign _064_ = digest_valid_we ? digest_update : digest_valid_reg;
  assign _009_ = reset_n ? _064_ : 1'b0;
  assign _065_ = a_e_we ? round_ctr_new : round_ctr_reg;
  assign _011_ = reset_n ? _065_ : 7'b0000000;
  assign _066_ = H_we ? H4_new : H4_reg;
  assign _004_ = reset_n ? _066_ : 32'd0;
  assign _067_ = H_we ? H3_new : H3_reg;
  assign _003_ = reset_n ? _067_ : 32'd0;
  assign _068_ = H_we ? H2_new : H2_reg;
  assign _002_ = reset_n ? _068_ : 32'd0;
  assign _069_ = H_we ? H1_new : H1_reg;
  assign _001_ = reset_n ? _069_ : 32'd0;
  assign _070_ = H_we ? H0_new : H0_reg;
  assign _000_ = reset_n ? _070_ : 32'd0;
  assign _071_ = a_e_we ? e_new : e_reg;
  assign _010_ = reset_n ? _071_ : 32'd0;
  assign _072_ = a_e_we ? d_new : d_reg;
  assign _008_ = reset_n ? _072_ : 32'd0;
  assign _073_ = a_e_we ? c_new : c_reg;
  assign _007_ = reset_n ? _073_ : 32'd0;
  assign _074_ = a_e_we ? b_new : b_reg;
  assign _006_ = reset_n ? _074_ : 32'd0;
  assign _075_ = a_e_we ? a_new : a_reg;
  assign _005_ = reset_n ? _075_ : 32'd0;
  assign _076_ = _049_ ^ _050_;
  assign _077_ = b_reg ^ c_reg;
  assign _078_ = _077_ ^ d_reg;
  assign _079_ = _060_ ^ _061_;
  assign _080_ = _079_ ^ _062_;
  logic [511:0] block_R0 ;
  logic [0:0] round_ctr_rst_R0 ;
  logic [0:0] round_ctr_inc_R0 ;
  logic [0:0] reset_n_R0 ;
// module: sha1_w_mem
  sha1_w_mem w_mem_inst (
    .clk ( clk ),
    .block ( block ),
    .w ( w ),
    .init ( round_ctr_rst ),
    .next ( round_ctr_inc ),
    .reset_n ( reset_n )
  );
  assign digest = { H0_reg, H1_reg, H2_reg, H3_reg, H4_reg };
  assign digest_valid = digest_valid_reg;
  assign digest_valid_new = digest_update;
  assign first_block = digest_init;
  assign ready_flag = ready;
  assign round_ctr_we = a_e_we;
  assign state_init = round_ctr_rst;
  assign state_update = round_ctr_inc;
  assign w_init = round_ctr_rst;
  assign w_next = round_ctr_inc;
  assign reset_n_R = ( reset_n_R0 );
  assign block_R = ( block_R0 );
  assign round_ctr_inc_R = ( round_ctr_inc_R0 );
  assign round_ctr_rst_R = ( round_ctr_rst_R0 );
  always @( posedge clk ) begin
    if( rst_zy ) a_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) a_reg_PREV_VAL1 <= a_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) b_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) b_reg_PREV_VAL1 <= b_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) c_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) c_reg_PREV_VAL1 <= c_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) d_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) d_reg_PREV_VAL1 <= d_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) e_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) e_reg_PREV_VAL1 <= e_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) H0_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) H0_reg_PREV_VAL1 <= H0_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) H1_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) H1_reg_PREV_VAL1 <= H1_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) H2_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) H2_reg_PREV_VAL1 <= H2_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) H3_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) H3_reg_PREV_VAL1 <= H3_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) H4_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) H4_reg_PREV_VAL1 <= H4_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) round_ctr_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) round_ctr_reg_PREV_VAL1 <= round_ctr_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) digest_valid_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) digest_valid_reg_PREV_VAL1 <= digest_valid_reg ;
  end
  always @( posedge clk ) begin
    if( rst_zy ) sha1_ctrl_reg_PREV_VAL1 <= 0 ;
    if( INSTR_IN_ZY ) sha1_ctrl_reg_PREV_VAL1 <= sha1_ctrl_reg ;
  end
 // ground taints for unused wire slices
  assert property( !INSTR_IN_ZY  || H0_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || H1_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || H2_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || H3_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || H4_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || a_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || b_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || c_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || d_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || digest_valid_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || e_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || round_ctr_reg_PREV_VAL1 == 0 );
  assert property( !INSTR_IN_ZY  || sha1_ctrl_reg_PREV_VAL1 == 0 );
endmodule
